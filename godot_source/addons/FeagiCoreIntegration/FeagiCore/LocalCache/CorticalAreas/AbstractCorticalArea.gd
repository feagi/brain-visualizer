extends GenomeObject
class_name AbstractCorticalArea
## Holds details pertaining to a specific cortical area
## Should not be instantiated directly

# Main functionality for cortical area, and base details such as ID, name, and positions
#region Base Functionality
## The type of cortical area, not 1-1 mapped with feagi
enum CORTICAL_AREA_TYPE {
	IPU,
	CORE,
	MEMORY,
	CUSTOM,
	OPU,
	UNKNOWN
}

## Any specific flags to be aware of for a cortical area? 
enum CORTICAL_FLAGS {
	EACH_AFFERENT_CONNECTION_MAX_ONE_MAPPING,
	EACH_EFFERENT_CONNECTION_MAX_ONE_MAPPING
}

signal cortical_visibility_updated(visibility: bool, this_cortical_area: AbstractCorticalArea)
signal cortical_neuron_per_vox_count_updated(density: int, this_cortical_area: AbstractCorticalArea)
signal cortical_synaptic_attractivity_updated(attractivity: int, this_cortical_area: AbstractCorticalArea)
signal changed_monitoring_membrane_potential(is_monitoring: bool)
signal changed_monitoring_synaptic_potential(is_monitoring: bool)



## Unique identifier of the cortical area, generated by FEAGI
var cortical_ID: StringName:
	get: return _genome_ID



## The base type of cortical area as understood by FEAGI
var cortical_type: CORTICAL_AREA_TYPE:
	get:  return _get_group()

var type_as_string: StringName:
	get: return AbstractCorticalArea.cortical_type_to_str(_get_group())

## Is cortical area visible?
var cortical_visibility: bool:
	get: return _cortical_visiblity

var cortical_neuron_per_vox_count: int:
	get: return _cortical_neuron_per_vox_count

var cortical_synaptic_attractivity: int:
	get: return _cortical_synaptic_attractivity

var are_details_placeholder_data: bool = true ## We don't have the true values for details yet

## Has a 2D location been specified in FEAGI yet or is still unknown?
var is_coordinates_2D_available: bool:
	get:  return _coordinates_2D_available

## Has a 3D location been specified in FEAGI yet or is still unknown?
var is_coordinates_3D_available: bool:
	get:  return _coordinates_3D_available

## Can a user edit the name of this cortical area?
var user_can_edit_name: bool:
	get: return _user_can_edit_name()

## Can a user edit the dimensions of this cortical area?
var user_can_edit_dimensions: bool:
	get: return _user_can_edit_dimensions()

## Can a user edit the dimensions of this cortical area?
var user_can_delete_this_area: bool:
	get: return _user_can_delete_area()

var user_can_edit_cortical_neuron_per_vox_count: bool:
	get: return _user_can_edit_cortical_neuron_per_vox_count()

var user_can_edit_cortical_synaptic_attractivity: bool:
	get: return _user_can_edit_cortical_synaptic_attractivity()

var user_can_clone_this_cortical_area: bool:
	get: return _user_can_clone_this_area()

var has_neuron_firing_parameters: bool:
	get:  return _has_neuron_firing_parameters()

var has_memory_parameters: bool:
	get: return _has_memory_parameters()

# Private Properties
var _cortical_neuron_per_vox_count: int = 1
var _cortical_synaptic_attractivity: int = 100
var _coordinates_2D_available: bool = false  # if coordinates_2D are available from FEAGI
var _coordinates_3D_available: bool = false  # if coordinates_3D are available from FEAGI
var _cortical_visiblity: bool = true

#TODO this shouldn't be here
## BV uses an alternate space for its coordinates currently, this acts as a translation
static func true_position_to_BV_position(true_position: Vector3, scale: Vector3) -> Vector3:
	return Vector3(
		(int(scale.x / 2.0) + true_position.x),
		(int(scale.y / 2.0) + true_position.y),
		-(int(scale.z / 2.0) + true_position.z))

## Array of Cortical Areas to Array of Cortical IDs
static func cortical_area_array_to_ID_array(arr: Array[AbstractCorticalArea]) -> Array[StringName]:
	var output: Array[StringName] = []
	for area: AbstractCorticalArea in arr:
		output.append(area.cortical_ID)
	return output

## From a string of cortical type, returns the cortical type enum
static func cortical_type_str_to_type(cortical_type_raw: String) -> CORTICAL_AREA_TYPE:
	cortical_type_raw = cortical_type_raw.to_upper()
	if cortical_type_raw in CORTICAL_AREA_TYPE.keys():
		return CORTICAL_AREA_TYPE[cortical_type_raw]
	else:
		push_error("Unknown Cortical Type " + cortical_type_raw +". Marking as INVALID!")
		return CORTICAL_AREA_TYPE.UNKNOWN

## From a human readable string of cortical type, to cortical type enum
static func cortical_type_human_readable_str_to_type(cortical_type_raw: String) -> CORTICAL_AREA_TYPE:
	cortical_type_raw = cortical_type_raw.to_lower()
	match(cortical_type_raw):
		"input":
			return CORTICAL_AREA_TYPE.IPU
		"output":
			return CORTICAL_AREA_TYPE.OPU
		"core":
			return CORTICAL_AREA_TYPE.CORE
		"interconnect":
			return CORTICAL_AREA_TYPE.CUSTOM
		"memory":
			return CORTICAL_AREA_TYPE.MEMORY
		_:
			return CORTICAL_AREA_TYPE.UNKNOWN


## Given a cortical type enum, return the string
static func cortical_type_to_str(cortical_type: CORTICAL_AREA_TYPE) -> StringName:
	return CORTICAL_AREA_TYPE.keys()[cortical_type]
	
## DO NOT init this object directly! use a subclass!
func _init(ID: StringName, cortical_name: StringName, cortical_dimensions: Vector3i, parent_region: BrainRegion, visiblity: bool = true):
	_genome_ID = ID
	_friendly_name = cortical_name
	_dimensions_3D = cortical_dimensions
	_cortical_visiblity = visiblity
	_init_self_to_brain_region(parent_region)


## Called from [CorticalAreasCache] when cortical area is being deleted
func FEAGI_delete_cortical_area() -> void:
	#NOTE: Assumption is made that connections were already removed firstZ!
	_parent_region.FEAGI_remove_a_cortical_area(self)
	about_to_be_deleted.emit()
	# [CorticalAreasCache] then deletes this object

## Applies every detail from the dictionary from FEAGI
func FEAGI_apply_full_dictionary(data: Dictionary) -> void:
	if data == {}:
		return
	if "cortical_id" not in data.keys():
		push_error("Input dictionary to update cortical area %s is invalid! Skipping!" % _genome_ID)
		return
	if data["cortical_id"] != _genome_ID:
		push_error("Input dictionary to update cortical area %s has sent to %s! Skipping!" % [data["cortical_id"], _genome_ID])
		return
	
	if "cortical_name" in data.keys():
		FEAGI_change_friendly_name(data["cortical_name"])
	if "cortical_visibility" in data.keys():
		FEAGI_set_cortical_visibility(data["cortical_visibility"])
	if "cortical_dimensions" in data.keys():
		FEAGI_change_dimensions_3D(FEAGIUtils.array_to_vector3i(data["cortical_dimensions"]))
	
	if "coordinates_2d" in data.keys():
		if data["coordinates_2d"][0] == null:
			_coordinates_2D_available = false
		else:
			FEAGI_change_coordinates_2D(FEAGIUtils.array_to_vector2i(data["coordinates_2d"]))

	if "coordinates_3d" in data.keys():
		if data["coordinates_3d"] == null:
			_coordinates_3D_available = false
		else:
			FEAGI_change_coordinates_3D(FEAGIUtils.array_to_vector3i(data["coordinates_3d"]))
	
	if "parent_region_id" in data.keys():
		if !(data["parent_region_id"] in FeagiCore.feagi_local_cache.brain_regions.available_brain_regions):
			push_error("Unable to find new region ID %s for cortical area %s" % [data["parent_region_id"], cortical_ID])
			return
		var new_region: BrainRegion = FeagiCore.feagi_local_cache.brain_regions.available_brain_regions[data["parent_region_id"]]
		FEAGI_change_parent_brain_region(new_region)
			

	FEAGI_apply_detail_dictionary(data)

# NOTE: This function applies all details (but not base information such as name, visibility, dimensions or positions), and may be expanded in other cortical types
## Updates all cortical details in here from a dict from FEAGI
func FEAGI_apply_detail_dictionary(data: Dictionary) -> void:
	
	are_details_placeholder_data = false # Assuming if ANY data is updated here, that all data here is not placeholders
	# Cortical Parameters
	if "cortical_neuron_per_vox_count" in data.keys(): 
		cortical_neuron_per_vox_count = data["cortical_neuron_per_vox_count"]
	if "cortical_synaptic_attractivity" in data.keys(): 
		cortical_synaptic_attractivity = data["cortical_synaptic_attractivity"]
	
	post_synaptic_potential_paramamters.FEAGI_apply_detail_dictionary(data)

	return

func FEAGI_set_cortical_visibility(is_visible: bool) -> void:
	if is_visible == _cortical_visiblity:
		return
	_cortical_visiblity = is_visible
	cortical_visibility_updated.emit(_cortical_visiblity, self)

func FEAGI_set_cortical_neuron_per_vox_count(new_density: int) -> void:
	if new_density == _cortical_neuron_per_vox_count:
		return
	_cortical_neuron_per_vox_count = new_density
	cortical_neuron_per_vox_count_updated.emit(new_density, self)

func FEAGI_set_cortical_synaptic_attractivity(new_attractivity: int) -> void:
	if new_attractivity == _cortical_synaptic_attractivity:
		return
	_cortical_synaptic_attractivity = new_attractivity
	cortical_synaptic_attractivity_updated.emit(new_attractivity, self)


# The following functions are often overridden in child classes
func _get_group() -> CORTICAL_AREA_TYPE:
	## OVERRIDE THIS
	return CORTICAL_AREA_TYPE.UNKNOWN

func _user_can_edit_dimensions() -> bool:
	return true

func _user_can_edit_name() -> bool:
	return true

func _user_can_delete_area() -> bool:
	return true

func _user_can_edit_cortical_neuron_per_vox_count() -> bool:
	return true

func _user_can_edit_cortical_synaptic_attractivity() -> bool:
	return true

func _user_can_clone_this_area() -> bool:
	return false

func _has_neuron_firing_parameters() -> bool:
	return false

func _has_memory_parameters() -> bool:
	return false


#endregion


#TODO this shouldn't be here
## Get 3D coordinates that BV uses currently
func BV_position() -> Vector3:
	return AbstractCorticalArea.true_position_to_BV_position(_coordinates_3D, _dimensions_3D)

# Functionality and references to how this cortical area is mapped / connected to other cortical areas / regions
#region Mapping

# NOTE: While we have connection links for pathing information for HOW connections are made to other objects, we 
# also have this to know WHAT we are connecting to, because sometimes we don't care about partial connections or regions

signal afferent_input_cortical_area_added(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal efferent_input_cortical_area_added(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal recursive_cortical_area_added(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal afferent_input_cortical_area_removed(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal efferent_input_cortical_area_removed(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal recursive_cortical_area_removed(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)

var afferent_mappings: Dictionary: # Key'd by the [AbstractCorticalArea] object, value is the related [InterCorticalMappingSet]
	get: return _afferent_mappings
var efferent_mappings: Dictionary: # Key'd by the [AbstractCorticalArea] object, value is the related [InterCorticalMappingSet]
	get: return _efferent_mappings
var recursive_mappings: Dictionary: # Key'd by the [AbstractCorticalArea] object, value is the related [InterCorticalMappingSet]
	get: return _recursive_mappings

var _afferent_mappings: Dictionary = {}
var _efferent_mappings: Dictionary = {}
var _recursive_mappings: Dictionary = {} # technically, this will only be of size 0 or 1 lol

func CACHE_mapping_set_register_an_afferent(mapping_set: InterCorticalMappingSet) -> void:
	_afferent_mappings[mapping_set.source_cortical_area] = mapping_set
	afferent_input_cortical_area_added.emit(mapping_set.source_cortical_area, mapping_set)

func CACHE_mapping_set_register_an_efferent(mapping_set: InterCorticalMappingSet) -> void:
	_efferent_mappings[mapping_set.destination_cortical_area] = mapping_set
	efferent_input_cortical_area_added.emit(mapping_set.destination_cortical_area, mapping_set)

func CACHE_mapping_set_register_a_recursive(mapping_set: InterCorticalMappingSet) -> void:
	_recursive_mappings[mapping_set.destination_cortical_area] = mapping_set
	recursive_cortical_area_added.emit(mapping_set.destination_cortical_area, mapping_set)

func CACHE_mapping_set_deregister_an_afferent(mapping_set: InterCorticalMappingSet) -> void:
	_afferent_mappings.erase(mapping_set.source_cortical_area)
	afferent_input_cortical_area_removed.emit(mapping_set.source_cortical_area, mapping_set)

func CACHE_mapping_set_deregister_an_efferent(mapping_set: InterCorticalMappingSet) -> void:
	_efferent_mappings.erase(mapping_set.destination_cortical_area)
	efferent_input_cortical_area_removed.emit(mapping_set.destination_cortical_area, mapping_set)

func CACHE_mapping_set_deregister_a_rescursive(mapping_set: InterCorticalMappingSet) -> void:
	_recursive_mappings.erase(mapping_set.source_cortical_area)
	recursive_cortical_area_removed.emit(mapping_set.source_cortical_area, mapping_set)

#endregion

#region Post Synaptic Potential Parameters

## Holds all post synaptic potential paramamters
var post_synaptic_potential_paramamters: CorticalPropertyPostSynapticPotentialParameters = CorticalPropertyPostSynapticPotentialParameters.new(self)
#endregion

# Monitoring settings for this specific cortical area
#region Monitoring Settings
var is_monitoring_membrane_potential: bool
var is_monitoring_synaptic_potential: bool
#endregion

